1. Типы данных в JavaScript?
 число, BigInt, строка, булевый (логический) тип, null, undefined, объект и символ.
 Оператор typeof в JavaScript используется для определения типа какого-либо значения.

Примитивные типы данных:

-Числа (Numbers): Они представляют как целые числа, так и числа с плавающей запятой. Например: 5, 3.14, 0xFF (шестнадцатеричное число).
-Строки (Strings): Строки представляют последовательность символов, заключенных в кавычки (одинарные или двойные). Например: 'Hello', "World".
-Логические значения (Boolean): Это простые логические значения true и false, которые представляют истину и ложь соответственно.
-Null: Это значение, которое представляет "ничего" или "пустоту". В JavaScript null - это специальное значение, которое указывает на отсутствие значения.
-Undefined: Это значение, которое получает переменная, когда ей не было присвоено никакого значения. Переменная, объявленная, но не инициализированная, имеет значение undefined.
-Символы (Symbols): Это уникальные и неизменяемые значения, которые часто используются в качестве идентификаторов для свойств объектов.

Сложные типы данных:
-Объекты (Objects): Объекты в JavaScript представляют собой коллекции пар ключ-значение, где ключи обычно являются строками, а значения могут быть любого типа данных, включая другие объекты или функции.
-Функции (Functions): В JavaScript функции являются объектами, что позволяет им быть присвоенными переменным, передаваться как аргументы другим функциям и возвращаться из других функций.
Это основные типы данных в JavaScript. Важно отметить, что JavaScript является языком с динамической типизацией, что означает, что тип данных переменной определяется автоматически на основе присвоенного значения.

2. Разница между == и === (нестрогое/строгое равенство)?

В JavaScript операторы == (нестрогое равенство) и === (строгое равенство) используются для сравнения значений и типов данных.

Нестрогое равенство (==):
При использовании оператора ==, JavaScript пытается привести оба операнда к одному типу данных перед сравнением.
Если типы данных операндов различны, JavaScript попытается привести их к общему типу.
Затем сравниваются значения.
Нестрогое равенство может приводить к неожиданным результатам из-за автоматического приведения типов. Например:
0 == '' вернет true, потому что оба значения приводятся к false.
1 == true также вернет true, потому что true приводится к числу 1.
Строгое равенство (===):
При использовании оператора ===, сравниваются значения и типы данных операндов без приведения типов.
Если значения и типы данных операндов идентичны, оператор === возвращает true, в противном случае возвращает false.
Строгое равенство рекомендуется использовать в большинстве случаев, поскольку оно обеспечивает более предсказуемое поведение и избегает ошибок, связанных с автоматическим приведением типов.

Например:

0 === '' вернет false, потому что 0 - это число, а '' - это строка.
1 === true вернет false, потому что 1 - это число, а true - это логическое значение.
В целом, рекомендуется использовать строгое равенство (===), так как это помогает избежать ошибок, связанных с неявным приведением типов данных.



3. Что такое Strict mode в JavaScript?
Strict mode (строгий режим) в JavaScript - это специальный режим, который позволяет вам работать в более строгом и безопасном режиме выполнения кода. Когда строгий режим включен, определенные дополнительные правила и ограничения применяются к выполнению JavaScript кода.

Некоторые из основных характеристик строгого режима:
Идентификатор "use strict": Строгий режим включается путем добавления строки "use strict"; в начало скрипта или функции.
Ошибка на некоторые ошибки: Строгий режим приводит к выбрасыванию ошибок в ситуациях, которые в обычном режиме просто проигнорировались бы. Например, попытка присвоения значения необъявленной переменной или удаление некоторых свойств объектов будет вызывать ошибку.
Запрет на использование некоторых устаревших и небезопасных функций: В строгом режиме некоторые функции и конструкции, которые считаются устаревшими или потенциально опасными (например, with), запрещены.
Более строгие правила для this: В строгом режиме значение this в функциях, вызванных без контекста, будет undefined, а не глобальным объектом (как это происходит в нестрогом режиме).
Более строгие правила для аргументов функций: В строгом режиме изменения в аргументах функции не отражаются в переменных arguments.
Использование строгого режима помогает выявить потенциальные ошибки в коде на ранних этапах разработки и повысить общую надежность и безопасность кода JavaScript. Он особенно полезен при разработке крупных проектов или при работе в команде, где строгость и безопасность кода имеют высокий приоритет.


4. Разница между function declaration и function expression?

Разница между функциональным объявлением (function declaration) и функциональным выражением (function expression) заключается в том, как они объявляются и в том, когда они доступны для использования в коде.

 Функциональное объявление (Function Declaration):
Функциональное объявление представляет собой объявление функции, которое начинается с ключевого слова function.
Оно может быть объявлено в любом месте в области видимости, и его можно вызвать до объявления (концепция поднятия, или hoisting).

  Функциональное выражение (Function Expression):
Функциональное выражение представляет собой присвоение функции переменной.
Оно обычно объявляется внутри выражения (например, присвоения значения переменной) или как аргумент другой функции.
Оно не доступно для вызова до момента, когда код, содержащий это выражение, выполнится.

Важно отметить, что разница в том, как интерпретируется код, может быть важна, особенно в случаях, когда порядок объявления функций имеет значение или когда нужно быть осторожным с поднятием. В целом, использование функциональных выражений чаще всего предпочтительно, так как это позволяет более точно контролировать видимость функции и ее поведение.


5. Разница между null и undefined?
В JavaScript null и undefined - это два разных значения, которые обозначают отсутствие значения, но они имеют некоторые различия:

undefined:

undefined означает, что переменная была объявлена, но ей не было присвоено никакое значение.
Переменной по умолчанию присваивается значение undefined, если она объявлена, но не инициализирована.
Возвращается в качестве значения переменной, если к ней обращаются до ее инициализации или если функция не возвращает никакого значения явно.
null:

null указывает на отсутствие значения.
Оно используется в тех случаях, когда нужно явно указать, что переменная не содержит никакого значения или ссылается на ничто.
В отличие от undefined, null является специальным значением, которое нужно присвоить переменной, чтобы указать на отсутствие значения.
Важно понимать, что undefined и null являются разными типами данных (undefined - это тип данных, а null - это значение типа данных). В большинстве случаев null используется программистами для явного указания отсутствия значения, в то время как undefined обычно возникает как результат некоторых операций в JavaScript.


6. Типы таймеров в JavaScript?

-setTimeout:
Функция setTimeout() используется для запуска выполнения указанной функции один раз через определенный интервал времени (в миллисекундах).
Синтаксис: setTimeout(callback, delay)
- setInterval:
Функция setInterval() используется для запуска выполнения указанной функции через определенные интервалы времени (в миллисекундах).
Синтаксис: setInterval(callback, interval)
-clearTimeout:
Функция clearTimeout() используется для отмены запланированного выполнения кода, созданного с помощью setTimeout().
Синтаксис: clearTimeout(timeoutID)
-clearInterval:
Функция clearInterval() используется для отмены запланированного выполнения кода, созданного с помощью setInterval().
Синтаксис: clearInterval(intervalID)
Пример:

7.Что такое поднятие (Hoisting)?
  Поднятие (Hoisting) - это механизм в JavaScript, при котором объявления переменных и функций "поднимаются" (происходит их перемещение) 
  вверх в контексте выполнения кода перед фактическим выполнением. Это позволяет вам использовать переменные или функции до их фактического объявления в коде.

В JavaScript, когда интерпретатор начинает выполнение скрипта, он сначала проходит по коду и поднимает все объявления переменных и функций на верхний 
уровень их области видимости. Это означает, что вы можете обращаться к переменным или функциям до того, как они фактически будут определены в коде.

Пример поднятия переменных:

console.log(x); // Выведет: undefined
var x = 5;

После поднятия код будет интерпретирован как:
var x;
console.log(x); // Выведет: undefined
x = 5;

Пример поднятия функций:
greet(); // Вызовет функцию "Hello!"
function greet() {
    console.log("Hello!");
}
После поднятия код будет интерпретирован как:
function greet() {
    console.log("Hello!");
}
greet(); // Вызовет функцию "Hello!"
Поднятие действует только на объявления переменных и функций, но не на их инициализацию (присваивание значений). Поэтому переменные, объявленные
 с использованием var, let или const, будут иметь значение undefined до того, как им будет присвоено фактическое значение.

Хотя поднятие может быть полезным инструментом, его использование может вызывать путаницу и ошибки в коде, особенно если вы полагаетесь на его 
поведение в неправильных ситуациях. Поэтому рекомендуется объявлять переменные и функции в начале блока или функции, чтобы избежать неожиданного поведения из-за поднятия.

8. Что такое область видимости (Scope)?

Область видимости (Scope) в JavaScript определяет доступность переменных и функций в течение выполнения программы. Она определяет, где и какие идентификаторы (переменные, функции) могут быть использованы в вашем коде.

Глобальная область видимости (Global Scope):
-Переменные и функции, объявленные в глобальной области видимости, доступны из любой части вашего кода, включая функции и блоки.
-Переменные и функции, объявленные без использования ключевых слов var, let или const, автоматически становятся частью глобальной области видимости.
-Глобальные переменные и функции могут быть использованы в любой части вашего кода, но их использование может привести к конфликтам имён и сложностям в поддержке и тестировании кода.

Локальная область видимости (Local Scope):
-Переменные и функции, объявленные внутри функции или блока кода, доступны только в пределах этой функции или блока кода.
-Переменные, объявленные с помощью ключевых слов var, let или const внутри функции, имеют локальную область видимости.
-Переменные с локальной областью видимости не могут быть доступны вне своей функции или блока кода, что помогает избежать конфликтов имён и обеспечивает большую изоляцию кода.


9. Разница между var, let и const?

var, let и const - это ключевые слова, используемые для объявления переменных в JavaScript. Они имеют некоторые различия в поведении и области видимости. Вот основные различия между ними:

var:

var было первым ключевым словом для объявления переменных в JavaScript.
Переменные, объявленные с помощью var, имеют функциональную область видимости (function scope). Это означает, что они доступны только внутри функции, в которой они были объявлены.
Переменные, объявленные с помощью var, поднимаются (hoisted) в начало своей области видимости.
Однако, переменные, объявленные с помощью var, могут быть повторно объявлены без ошибки.
let:

let было введено в ECMAScript 6 (ES6) для решения некоторых проблем, связанных с var.
Переменные, объявленные с помощью let, имеют блочную область видимости (block scope). Это означает, что они доступны только внутри блока кода, в котором они были объявлены (например, внутри функции, цикла или условного оператора).
Переменные, объявленные с помощью let, не поднимаются (hoisted) в начало своей области видимости.
Переменные, объявленные с помощью let, не могут быть повторно объявлены в той же области видимости, что и const.
const:

const также было введено в ECMAScript 6 (ES6) и используется для объявления переменных с неизменяемым (константным) значением.
Переменные, объявленные с помощью const, также имеют блочную область видимости (block scope).
Переменные, объявленные с помощью const, не могут быть переназначены. Однако, если переменная является объектом или массивом, то значения внутри объекта или массива могут быть изменены.
Как и переменные, объявленные с помощью let, переменные const не поднимаются (hoisted) в начало своей области видимости.
В общем случае, рекомендуется использовать let для объявления переменных, которые могут изменяться, и const для объявления переменных, которые должны оставаться неизменными. Использование var обычно не рекомендуется из-за его функциональной области видимости и других проблем, связанных с поднятием (hoisting) и повторным объявлением переменных.





10. Что такое замыкание (Closure)?
Замыкание (Closure) - это особенность в JavaScript, которая позволяет функции запоминать и иметь доступ к своей лексической области видимости, даже когда эта функция выполняется вне этой области видимости.

Простым образом, замыкание возникает, когда функция определена внутри другой функции и имеет доступ к переменным этой внешней функции, даже после того, как внешняя функция завершила свое выполнение.

Пример замыкания:

function outerFunction() {
    var outerVariable = "I'm from outer function";

    function innerFunction() {
        console.log(outerVariable); // innerFunction сохраняет доступ к outerVariable
    }

    return innerFunction;
}

var closureExample = outerFunction(); // вызов внешней функции
closureExample(); // вызов внутренней функции, которая использует замыкание
В этом примере функция innerFunction() является замыканием. Она сохраняет доступ к переменной outerVariable, которая определена внутри функции outerFunction(), даже после того, как outerFunction() завершила свое выполнение. Таким образом, замыкание позволяет функции сохранять свое окружение, включая локальные переменные и параметры, и использовать их в будущем.

Замыкания используются в JavaScript для создания приватных переменных, функций обратного вызова (callback functions), функций высшего порядка (higher-order functions) и других мощных концепций программирования. Они играют ключевую роль в функциональном программировании и яв


















